#
# cs2 items game dumper
#
# (c) 2023 oxiKKK
#

import argparse
import vdf
import sys
import datetime
import os

parser = argparse.ArgumentParser(
    description="CS2 items_game.txt dumper -- dumps the whole file depending on settings."
)

# dump X
parser.add_argument(
    "-d",
    "--dump",
    choices=["items"],
    nargs='+',
    type=str,
    help="specifies what needs to be dumped",
)

# input file argument
parser.add_argument("input", nargs='+', type=str, help="file to be processed")

# parse arguments
args = parser.parse_args()

current_input_file = ""

prefabs = any


def dump_items(items):
    print(f'dumping {len(items)} items...')
    try:
        if not os.path.exists('out'):
            os.makedirs('out')  # NOTE: this is a real hack
        f = open('out/definition_items.cc', 'w')
    except:
        print(f'error: cannot open output file.')
        return

    # preamble
    f.write(
        f"// file generated by CS2 items_game.txt dumper on {datetime.datetime.now()}\n")
    f.write(f"// \n")
    f.write(f"// input file: {current_input_file}\n")
    f.write(f"// {len(items)} items\n\n")

    # structure
    f.write(f"struct item_t\n")
    f.write(f"{{\n")
    f.write(f"\t// item name\n")
    f.write(f"\tconst char* name{{nullptr}};\n")
    f.write(f"\t// item price, how much does it cost in-game;\n")
    f.write(f"\tint32_t cost{{-1}};\n")
    f.write(f"\t// weapon type string;\n")
    f.write(f"\tconst char* weapon_type{{nullptr}};\n")
    f.write(f"}};\n\n")

    # items
    f.write(
        f'std::unordered_map<size_t, item_t> g_definition_item_list =\n')
    f.write(
        f'{{\n')

    for definition_index, item in items.items():
        item_name = item['name']
        price = 0
        weapon_type = ""
        item_prefab_name = ""
        try:
            item_prefab_name = item['prefab']

            # get item in-game price
            try:
                price = int(prefabs[item_prefab_name]
                            ['attributes']['in game price'])
            except:
                price = 0

             # get weapon type
            try:
                weapon_type = prefabs[item_prefab_name]['visuals']['weapon_type']
            except:
                pass
        except:
            pass

        f.write(
            f"\t{{ {definition_index}, {{ \"{item_name}\", {price}, \"{weapon_type}\" }} }},\n")

    f.write(
        f'}};\n')


def get_items(d: vdf.VDFDict):
    """returns a dict where the key is definition index and the value is the item."""

    result = {}

    print(f"getting {len(d['items_game']['items'])} items...")

    for key, item in d['items_game']['items'].items():
        if key == "default":
            # the first entry
            definition_index = 0
        else:
            # try to get the definition index
            try:
                definition_index = int(key)
            except:
                continue

        result[definition_index] = item

        # item_name = item['name']
        # print(f"{definition_index}: {item_name}")

    print('done.')
    return result


def get_prefabs(d: vdf.VDFDict):
    """returns a dict where the key is the prefab name and the value is the prefab."""

    print(f"getting {len(d['items_game']['prefabs'])} prefabs...")
    result = d['items_game']['prefabs']
    print('done.')

    return result


def main():
    # check for amount of arguments
    if len(sys.argv) <= 1:
        return

    for file in args.input:
        # first get the vdf string
        try:
            vdf_string = vdf.dumps(vdf.load(open(file, 'r')))
        except:
            print(f"error: failed to open {file}.")
            continue

        global current_input_file
        current_input_file = file

        # now load the vdf object as VDFDict, this allows to contain multiple keys
        d = vdf.loads(vdf_string, mapper=vdf.VDFDict)

        global prefabs
        prefabs = get_prefabs(d)

        if 'items' in args.dump:
            dump_items(get_items(d))

        print('end.')

        # print(vdf.dumps(d, pretty=True))

     # dump_items((d['items_game']['items']))


if __name__ == "__main__":
    main()
